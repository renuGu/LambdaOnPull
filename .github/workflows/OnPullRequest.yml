name: Send git diff to Lambda

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  job-pass-diff-to-lambda:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get git diff
        run: |
          git diff origin/main...HEAD > diff.txt

      - name: Upload diff artifact
        uses: actions/upload-artifact@v4
        with:
          name: pr-diff
          path: diff.txt
      - name: Download diff artifact
        uses: actions/download-artifact@v4
        with:
          name: pr-diff
          path: .

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-2

      - name: Invoke Lambda
        run: |
          aws lambda invoke \
            --function-name arn:aws:lambda:us-east-2:772837503944:function:CallBedrockModel2 \
            --cli-binary-format raw-in-base64-out \
            --payload "$(jq -Rs '{diff: .}' diff.txt)" \
            response.json

      - name: Show Lambda response
        run: cat response.json
        
      - name: Pretty-print JSON
        run: |
          jq -R 'fromjson' response.json > response1.json

      - name: Upload analysis result
        uses: actions/upload-artifact@v4
        with:
          name: ai-code-analysis
          path: response1.json
      
      - name: Process Lambda Output to File
        run: |
            # 1. Extract the 'body' field and unescape it once
            # 2. Use 'grep' to keep only the lines that are actual JSON objects (starts with {)
            # 3. Use 'jq' to pretty-print the result into a file
            
            #echo "$RAW_RESPONSE" | jq -r '.body | fromjson' | grep '^{' | jq -s '.' > report.json
            cat response.json | jq -r '.body | fromjson' | grep '^{' | jq -s '.' > report.json

            # Optional: Verify the file was created
            echo "Report created successfully: report.json"
            ls -lh report.json
            cat report.json
     
      - name: Upload report 
        uses: actions/upload-artifact@v4
        with:
          name: code-Ai-report
          path: report.json


      - name: Format Lambda Output using GithubSummary
        env:
         LAMBDA_OUTPUT: response.json
         #LAMBDA_OUTPUT: '${{ steps.invoke_lambda.outputs.response }}' # Replace with your actual output variable
        run: |
            echo "### ðŸš€ Code Analysis Report" >> $GITHUB_STEP_SUMMARY
    
            # 1. Extract the 'body' string
            # 2. Use 'fromjson' to unescape it
            # 3. Use 'split' to remove the text before the JSON (like the </think> tag)
            # 4. Filter only lines that start with '{' and parse them
            
            echo "$LAMBDA_OUTPUT" | jq -r '.body | fromjson' | \
            grep '^{' | while read -r line; do
            echo "#### File: $(echo "$line" | jq -r '.filename')" >> $GITHUB_STEP_SUMMARY
            echo '```json' >> $GITHUB_STEP_SUMMARY
            echo "$line" | jq '.' >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "---" >> $GITHUB_STEP_SUMMARY
            done
       
      - name: Format Lambda Output with Python
        run: |
            python3 - <<EOF
            import json
            import re

            # 1. Load the raw file from the Lambda invocation
            with open('response.json', 'r') as f:
                data = json.load(f)

            # 2. Extract and unescape the 'body'
            # This handles the literal \n and \" sequences
            body_content = data.get('body', '')
            
            # 3. Clean the 'thinking' tags and garbage text
            # We look for anything that looks like a JSON object starting with {"filename"
            json_objects = re.findall(r'\{"filename".+?\}', body_content, re.DOTALL)

            cleaned_data = []
            for obj in json_objects:
                try:
                    # Parse each string as a real JSON object
                    cleaned_data.append(json.loads(obj))
                except Exception as e:
                    continue

            # 4. Save to a pretty-printed file
            with open('report2.json', 'w') as f:
                json.dump(cleaned_data, f, indent=4)

            print("Successfully created report2.json")
            EOF

      - name: View the Report
        run: cat report2.json

      - name: Format Lambda Output with Python (Resilient Version)
        run: |
            python3 - <<EOF
            import json

            try:
                # 1. Load the raw file
                with open('response.json', 'r') as f:
                    data = json.load(f)

                # 2. Get the 'body' and unescape it
                # The body itself is a string that contains JSON-per-line
                raw_body = data.get('body', '')
                unescaped_body = json.loads(f'"{raw_body}"') if not raw_body.startswith('{') else raw_body

                cleaned_data = []
                
                # 3. Split by newline and try to parse each line
                # This skips the "thinking" tags and empty lines automatically
                for line in unescaped_body.split('\n'):
                    line = line.strip()
                    if line.startswith('{"filename"'):
                        try:
                            cleaned_data.append(json.loads(line))
                        except json.JSONDecodeError:
                            continue

                # 4. Save to report3.json
                if cleaned_data:
                    with open('report3.json', 'w') as f:
                        json.dump(cleaned_data, f, indent=4)
                    print(f"Successfully processed {len(cleaned_data)} files.")
                else:
                    print("Warning: No valid JSON objects found in body.")
                    
            except Exception as e:
                print(f"Error: {str(e)}")
            EOF

      - name: Check Output
        run: |
            if [ -s report3.json ]; then
            cat report3.json
            else
            echo "report.json is still empty. Check your response.json content."
            fi